class Patient: # define a class to store each patients information
    def __init__(self, name, age, id, gender, medical_history, current_condition, admission_date, appointment_time): # all attributes associated with a patient record
        self.name = name
        self.age = age
        self.id = id
        self.gender = gender
        self.medical_history = medical_history
        self.current_condition = current_condition
        self.admission_date = admission_date
        self.appointment_time = appointment_time

    def __str__(self): # a function to display the patients records
        return f"Patient Name: {self.name}, Patient Age: {self.age}, Patient ID: {self.id}, Patient Gender: {self.gender}, Patient Medical History: {self.medical_history}, Patient Current Condition: {self.current_condition}, Patient Admission Date: {self.admission_date}, Appointment Time: {self.appointment_time}}"

class Appointment: # define a class to store each appointment made by a patient
    def __init__(self, patient, doctor, time): # all attributes associates with an appointment
        self.patient = patient
        self.doctor = doctor
        self.time = time

    def __str__(self): # a function to display the appointment information
        return f"Patient Name: {self.patient}, Doctor Name: {self.doctor}, Time: {self.time}"

class Prescription:
    def __init__(self, patient_name, medications):
        self.patient_name = patient_name
        self.medications = medications

    def __str__(self):
        return f"Prescription for Patient {self.patient_name}: {self.medications}"

class Stack:
    def __init__(self):
        self.items = []

    def push(self, item):
        self.items.append(item)

    def pop(self):
        if not self.is_empty():
            return self.items.pop()

    def is_empty(self):
        return len(self.items) == 0
class Node: # a class to define a node
    def __init__(self, patient):
        self.left = None
        self.right = None
        self.patient = patient

def insert(root, patient):
    if root is None:
        return Node(patient)
    else:
        if root.patient.id < patient.id:
            root.right = insert(root.right, patient)
        else:
            root.left = insert(root.left, patient)
    return root


def inorder_traversal(root):
    if root:
        inorder_traversal(root.left)
        print("Name:", root.patient.name)
        print("Age:", root.patient.age)
        print("ID:", root.patient.id)
        print("Gender:", root.patient.gender)
        print("Medical History:", root.patient.medical_history)
        print("Current Condition:", root.patient.current_condition)
        print("Admission Date:", root.patient.admission_date)
        print()
        inorder_traversal(root.right)

class PatientRecordManagementSystem: # defines a class for the hospital system, specifically patient record management
    def __init__(self):
        self.patient_record = {} # dictionary to store patient record
        self.appointments = [] # list to store appointments
        self.queue = [] # queue to maintain waiting line for consulatation, ensuring a FIFO order
        self.stack = Stack() # we used the stack to manage the description of the patient's
        self.root = None

    def add_patient_record(self, name, age, id, gender, medical_history, current_condition, admission_date): # Adding a new patient record using BST data structure
        new_patient = Patient(name, age, id, gender, medical_history, current_condition, admission_date, None)
        self.root = insert(self.root, new_patient)
        self.patient_record[id] = new_patient

    def update_patient_record(self, root, id, new_medical_history, new_current_condition):  # Updating a patient record using BST data structure
        if root is None:
            return
        if root.patient.id == id:
            root.patient.medical_history = new_medical_history
            root.patient.current_condition = new_current_condition
        elif root.patient.id < id:
            self.update_patient_record(root.right, id, new_medical_history, new_current_condition)
        else:
            self.update_patient_record(root.left, id, new_medical_history, new_current_condition)

    def remove_patient_record(self, root, id): # Removing a patient record using BST data structure
        if root is None: # If the root is None, meaning the tree is empty or the patient record with the given ID does not exist, the function returns None.
            return root
        if id < root.patient.id: # If the ID to be removed is less than the current root's patient ID, the function recursively calls itself on the left subtree.
            root.left = self.remove_patient_record(root.left, id)
        elif id > root.patient.id: # If the ID to be removed is greater than the current root's patient ID, the function recursively calls itself on the right subtree.
            root.right = self.remove_patient_record(root.right, id)
        else: # If the ID matches the current root's patient ID, there are three cases to consider:
            if root.left is None: # If the root has no left child, the right child replaces the root.
                return root.right
            elif root.right is None: # If the root has no right child, the left child replaces the root.
                return root.left
            # Find the minimum value in the right subtree
            successor = root.right
            while successor.left is not None:
                successor = successor.left
            root.patient = successor.patient
            root.right = self.remove_patient_record(root.right, successor.patient.id)
        return root

    def schedule_appointment(self, patient, doctor, time):# Scheduling an appointment for a patient with a specific doctor.#adjust time format for the users input!
        if patient_id in self.patient_record:
            patient = self.patient_record[patient_id]
            if patient not in self.queue:
                appointment_time_parts = time.split(":")
                if len(appointment_time_parts)==1:
                    time +=":00"
                    patient.appointment_time = time
                    appointment = Appointment(patient, doctor, time)
                    self.appointments.append(appointment)
                    # Print the details of the newly added appointment
                    print(f"Appointment scheduled for {appointment.patient} with {appointment.doctor} at {appointment.time}")
                else:
                    print("patient is alraedy in the queue")
            else:
                print("not in the recodrds..")

        

    def sort_records_by_date(self): # Create a hash table to organize patient records by admission date
        hash_table = {}
        for patient_id, patient in self.patient_record.items():
            if patient.admission_date in hash_table:
                hash_table[patient.admission_date].append(patient)
            else:
                hash_table[patient.admission_date] = [patient]

        # Sort the keys of the hash table (admission dates)
        sorted_keys = sorted(hash_table.keys())

        # Retrieve the records in sorted order
        sorted_records = []
        for key in sorted_keys:
            sorted_records.extend(hash_table[key])

        return sorted_records

    # Maintaining a line of patients waiting for consultations ensuring FIFO (First-In-First-Out) order using the Queue data structure.
    def enqueue(self, patient): # Adding patients to the consultation queue
        sorted_patients = self.sort_records_by_date()
        for patient in sorted_patients:
            if patient not in self.queue:  # Check if patient is already in the queue
                self.queue.append(patient)
                print(f"{patient.name} has been added to the queue.")

    def dequeue(self): # Removing patients from consultation queue
        if not self.is_empty():
            removed_patient = self.queue.pop(0)
            print(f"{removed_patient.name} has been called for consultation.")
            return removed_patient
        else:
            print("The queue is empty.")

    def is_empty(self): # checks if the queue is empty
        return len(self.queue) == 0

    def display_queue(self):# displaying all patients records within the queue#display in order of admission date!
         sorted_queue = sorted(self.queue, key=lambda patient: patient.admission_date)
        for patient in sorted_queue:
            print(f"Name: {patient.name}, Age: {patient.age}, ID: {patient.id}, Gender: {patient.gender}, Medical History: {patient.medical_history}, Current Condition: {patient.current_condition}, Admission Date: {patient.admission_date}, Appointment Time: {patient.appointment_time}")

    def issue_prescription(self, patient_name, medications):
        for patient_id, patient in self.patient_record.items():
            if patient.name == patient_name:
                prescription = Prescription(patient_name, medications)
                self.stack.push(prescription)
                return prescription
        else:
            print("Patient not found in records. Prescription cannot be issued.")
            return None

    def display_prescription_stack(self): #Here we added a function
        if not self.stack.is_empty():
            for prescription in self.stack.items:
                print(prescription)
        else:
            print("Prescription stack is empty.")

    def dispense_prescription(self):
        if not self.stack.is_empty():
            prescription = self.stack.pop()
            print(f"Prescription dispensed for Patient {prescription.patient_name}.")
            return prescription
        else:
            print("Prescription stack is empty. No prescription to dispense.")
            return None
            
######
#Test Case 2: 
def search(self, patient_id):
    if patient_id in self.patient_record:
        patient = self.patient_record[patient_id]
        appointment = None 
        medications = None
        for app in self.appointments:
            is app.patient.id == patient_id:
            appointment = app
            break
        for pres in self.stack.items:
            if pres.patient_name == patient.name:
                medications = pres.medications
                break
        print("Pacient search summary: ")
        summary = {"Patients name": patient.name, "Age": patient.age, "ID": patient.id, "Gender": patient.gender, "Medical condition" : patient.current_condition, "Admission Date": patient.admission_date, "Appointment Time", "Not schedueled", "Medications": if medications medications else "No medicine prescribed"}
        if appointment:
            summary["Appointment Time"] = appointment.time.split(" ")[1] if len (appointment.time.split(" ")) >= 2 else "Not scheduled"
        print(summary)
    else:
        print("There is no patients here!")

    
def input_guide(self):#while loop, the user will keep adding input till they pick to exit since the while loop keeps going!
    while True:
        print("Patients Records: ")
        print("1. Give the patients records: ")
        print("2. Change/update patients record: ")
        print("3. Delete patients record: ")
        print("4. Make an appointment scheduale: ")
        print("5. Add the patient to a queue after making apointment: ")
        print("6. Make prescription: ")
        print("7. All patients prescriptions: ")
        print("8. Despens the prescription: ")
        print("9. Show queue based on admission date: ")
        print("10. Search patient based on their ID: ")
        print("11. Exit")
        opt = input("write your pick: ")

        if opt == "1":
            name = input("write patients name: ")
            age = int(input("write patients age: "))
            patient_id = int(input("write patient ID: "))
            gender = input("write patients gender: ")
            medical_history = input("write patients medical history: ")
            current_condition = input("write the patints current condition: ")
            admission_date = input("write admission date as (yyyy-mm-dd): ")
            self.add_patient_record(name, age, patient_id, gender, medical_history, current_condition, admission_date) 
        elif: opt == "2":
            id = int(input("write patient ID to update: "))
            new_medical_history = input("write new medical history: ")
            new_current_condition = input("write new condition: ")
            self.update_patient_record(self.root, id, new_medical_history, new_current_condition)
        elif: opt == "3":
            id = int(input("write patients ID to delete the records: "))
            self.root = self.remove_patient_record(self.root, id)
        elif: opt == "4": 
            patient_id = int(input("write patient ID for the appointment: "))
            doctor = input("write the Doctors name: ")
            time = input("write the time of appointment as (hh:mm): ")
            self.schedule_appointment(patient_id, doctor, time)
        elif: opt == "5":
            patient_id = int(input("write patient ID to add them to queue"))
            self.enqueue(self.patient_record[patient_id])
        elif: opt == "6":
            patient_name = input("write the patients name for identifier: ")
            medications = input("write the given medicen: ")
            self.issue_prescription(patient_name, medications)
        elif: opt == "7":
            self.display_prescription_stack()
        elif: opt == "8":
            self.dispense_prescription()
        elif: opt =="9":
            self.display_queue()

        elif: opt == "10":
            patient_id = int(input("write patient ID to search them: "))
            self.search(patient_id)
        elif: opt == "11":
            print("Stopping/exiting: ")
            break
        else:
            print("Incorrect input, try to use the nums 1 - 11!")
if __name__ == "__main__":
    prms = PatientRecordManagementSystem()
    while True:
        prms.input_guide()
